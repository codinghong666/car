C251 COMPILER V5.60.0,  can                                                                11/07/24  00:41:03  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE can
OBJECT MODULE PLACED IN .\Objects\can.obj
COMPILER INVOKED BY: C:\Keil\C251\BIN\C251.EXE User_Group\can.c XSMALL BROWSE INCDIR(.\H_Group;.\User_Group) DEBUG PRINT
                    -(.\Listings\can.lst) TABS(2) OBJECT(.\Objects\can.obj) 

stmt  level    source

    1          #include "./H_Group/can.h"
    2          bit B_Can1Send = 0;
    3          bit B_Can1Read = 0;
    4          
    5          CAN_DataDef CAN1_Tx;
    6          CAN_DataDef CAN1_Rx[8];
    7          
    8          unsigned char CanReadReg(unsigned char addr)
    9          {
   10   1          CANAR = addr;
   11   1          return CANDR;
   12   1      }
   13          
   14          void CanWriteReg(unsigned char addr, unsigned char dat)
   15          {
   16   1          CANAR = addr;
   17   1          CANDR = dat;
   18   1      }
   19          
   20          void CanSetBaudrate(void) // 500Kbps@52MHz
   21          {
   22   1          CanWriteReg(MR, 0x04);   // Ê¹ÄÜResetÄ£Ê½
   23   1          CanWriteReg(BTR0, 0xc3); // SJW(3), BRP(3)
   24   1          CanWriteReg(BTR1, 0xc6); // SAM(1), TSG2(4), TSG1(6)
   25   1          CanWriteReg(MR, 0x00);   // ÍË³öResetÄ£Ê½
   26   1      }
   27          
   28          void CanReadFifo(CAN_DataDef *CAN)
   29          {
   30   1          u8 i;
   31   1          u8 pdat[5];
   32   1          u8 RX_Index = 0;
   33   1      
   34   1          pdat[0] = CanReadReg((u8)(RX_BUF0 + (RX_Index++ & 3)));
   35   1      
   36   1          if (pdat[0] & 0x80) // ÅÐ¶ÏÊÇ±ê×¼Ö¡»¹ÊÇÀ©Õ¹Ö¡
   37   1          {
   38   2              pdat[1] = CanReadReg((u8)(RX_BUF0 + (RX_Index++ & 3))); // À©Õ¹Ö¡IDÕ¼4¸ö×Ö½Ú
   39   2              pdat[2] = CanReadReg((u8)(RX_BUF0 + (RX_Index++ & 3)));
   40   2              pdat[3] = CanReadReg((u8)(RX_BUF0 + (RX_Index++ & 3)));
   41   2              pdat[4] = CanReadReg((u8)(RX_BUF0 + (RX_Index++ & 3)));
   42   2              CAN->ID = (((u32)pdat[1] << 24) + ((u32)pdat[2] << 16) + ((u32)pdat[3] << 8) + pdat[4]) >> 3;
   43   2          }
   44   1          else
   45   1          {
   46   2              pdat[1] = CanReadReg((u8)(RX_BUF0 + (RX_Index++ & 3))); // ±ê×¼Ö¡IDÕ¼2¸ö×Ö½Ú
   47   2              pdat[2] = CanReadReg((u8)(RX_BUF0 + (RX_Index++ & 3)));
   48   2              CAN->ID = ((pdat[1] << 8) + pdat[2]) >> 5;
   49   2          }
   50   1      
   51   1          CAN->FF = pdat[0] >> 7;  // Ö¡¸ñÊ½
   52   1          CAN->RTR = pdat[0] >> 6; // Ö¡ÀàÐÍ
   53   1          CAN->DLC = pdat[0];      // Êý¾Ý³¤¶È
   54   1      
   55   1          for (i = 0; ((i < CAN->DLC) && (i < 8)); i++) // ¶ÁÈ¡Êý¾Ý³¤¶ÈÎªlen£¬×î¶à²»³¬¹ý8
   56   1          {
   57   2              CAN->DataBuffer[i] = CanReadReg((u8)(RX_BUF0 + (RX_Index++ & 3))); // ¶ÁÈ¡ÓÐÐ§Êý¾Ý
   58   2          }
C251 COMPILER V5.60.0,  can                                                                11/07/24  00:41:03  PAGE 2   

   59   1          while (RX_Index & 3) // ÅÐ¶ÏÒÑ¶ÁÊý¾Ý³¤¶ÈÊÇ·ñ4µÄÕûÊý±¶
   60   1          {
   61   2              CanReadReg((u8)(RX_BUF0 + (RX_Index++ & 3))); // ¶ÁÈ¡Ìî³äÊý¾Ý£¬Ò»Ö¡Êý¾ÝÕ¼¾Ý4µÄÕûÊý±¶»º³åÇø¿Õ¼ä£¬²
             -»×ã²¹0
   62   2          }
   63   1      }
   64          
   65          u8 CanReadMsg(CAN_DataDef *CAN)
   66          {
   67   1          u8 i;
   68   1          u8 n = 0;
   69   1          do
   70   1          {
   71   2              CanReadFifo(&CAN[n++]); // ¶ÁÈ¡½ÓÊÕ»º³åÇøÊý¾Ý
   72   2              i = CanReadReg(SR);
   73   2          } while (i & 0x80); // ÅÐ¶Ï½ÓÊÕ»º³åÇøÀïÊÇ·ñ»¹ÓÐÊý¾Ý£¬ÓÐµÄ»°¼ÌÐø¶ÁÈ¡
   74   1      
   75   1          return n; // ·µ»ØÖ¡¸öÊý
   76   1      }
   77          
   78          void CanSendMsg(CAN_DataDef *CAN)
   79          {
   80   1          u32 CanID;
   81   1          u8 RX_Index, i;
   82   1      
   83   1          if (CANSEL == CAN1) // ÅÐ¶ÏÊÇ·ñCAN1
   84   1          {
   85   2              while (B_Can1Send)
   86   2                  ; // µÈ´ýCAN1ÉÏ´Î·¢ËÍÍê³É
   87   2          }
   88   1      
   89   1          if (CAN->FF) // ÅÐ¶ÏÊÇ·ñÀ©Õ¹Ö¡
   90   1          {
   91   2              CanID = CAN->ID << 3;
   92   2              CanWriteReg(TX_BUF0, CAN->DLC | ((u8)CAN->RTR << 6) | 0x80); // bit7: ±ê×¼Ö¡(0)/À©Õ¹Ö¡(1), bit6: 
             -Êý¾ÝÖ¡(0)/Ô¶³ÌÖ¡(1), bit3~bit0: Êý¾Ý³¤¶È(DLC)
   93   2              CanWriteReg(TX_BUF1, (u8)(CanID >> 24));
   94   2              CanWriteReg(TX_BUF2, (u8)(CanID >> 16));
   95   2              CanWriteReg(TX_BUF3, (u8)(CanID >> 8));
   96   2              CanWriteReg(TX_BUF0, (u8)CanID);
   97   2      
   98   2              RX_Index = 1;
   99   2              for (i = 0; ((i < CAN->DLC) && (i < 8)); i++) // Êý¾Ý³¤¶ÈÎªDLC£¬×î¶à²»³¬¹ý8
  100   2              {
  101   3                  CanWriteReg((u8)(TX_BUF0 + (RX_Index++ & 3)), CAN->DataBuffer[i]); // Ð´ÈëÓÐÐ§Êý¾Ý
  102   3              }
  103   2              while (RX_Index & 3) // ÅÐ¶ÏÒÑ¶ÁÊý¾Ý³¤¶ÈÊÇ·ñ4µÄÕûÊý±¶
  104   2              {
  105   3                  CanWriteReg((u8)(TX_BUF0 + (RX_Index++ & 3)), 0x00); // Ð´ÈëÌî³äÊý¾Ý£¬Ò»Ö¡Êý¾ÝÕ¼¾Ý4µÄÕûÊý±¶»º
             -³åÇø¿Õ¼ä£¬²»×ã²¹0
  106   3              }
  107   2          }
  108   1          else // ·¢ËÍ±ê×¼Ö¡
  109   1          {
  110   2              CanID = (u16)(CAN->ID << 5);
  111   2              CanWriteReg(TX_BUF0, CAN->DLC | ((u8)CAN->RTR << 6)); // bit7: ±ê×¼Ö¡(0)/À©Õ¹Ö¡(1), bit6: Êý¾ÝÖ¡(
             -0)/Ô¶³ÌÖ¡(1), bit3~bit0: Êý¾Ý³¤¶È(DLC)
  112   2              CanWriteReg(TX_BUF1, (u8)(CanID >> 8));
  113   2              CanWriteReg(TX_BUF2, (u8)CanID);
  114   2      
  115   2              RX_Index = 3;
  116   2              for (i = 0; ((i < CAN->DLC) && (i < 8)); i++) // Êý¾Ý³¤¶ÈÎªDLC£¬×î¶à²»³¬¹ý8
  117   2              {
  118   3                  CanWriteReg((u8)(TX_BUF0 + (RX_Index++ & 3)), CAN->DataBuffer[i]); // Ð´ÈëÓÐÐ§Êý¾Ý
  119   3              }
  120   2              while (RX_Index & 3) // ÅÐ¶ÏÒÑ¶ÁÊý¾Ý³¤¶ÈÊÇ·ñ4µÄÕûÊý±¶
C251 COMPILER V5.60.0,  can                                                                11/07/24  00:41:03  PAGE 3   

  121   2              {
  122   3                  CanWriteReg((u8)(TX_BUF0 + (RX_Index++ & 3)), 0x00); // Ð´ÈëÌî³äÊý¾Ý£¬Ò»Ö¡Êý¾ÝÕ¼¾Ý4µÄÕûÊý±¶»º
             -³åÇø¿Õ¼ä£¬²»×ã²¹0
  123   3              }
  124   2          }
  125   1          CanWriteReg(CMR, 0x04); // ·¢ÆðÒ»´ÎÖ¡´«Êä
  126   1      
  127   1          if (CANSEL == CAN1) // ÅÐ¶ÏÊÇ·ñCAN1
  128   1          {
  129   2              B_Can1Send = 1; // ÉèÖÃCAN1·¢ËÍÃ¦±êÖ¾
  130   2          }
  131   1      }
  132          
  133          void PortSwitch(void)
  134          {
  135   1          P_SW1 &= ~0x30; // CAN1: CANRX(P0.0), CANTX(P0.1)
  136   1      }
  137          
  138          void Can_Init(void)
  139          {
  140   1          CANEN = 1;     // ´ò¿ªCAN1Ä£¿é
  141   1          CANSEL = CAN1; // Ñ¡ÔñCAN1Ä£¿é
  142   1          PortSwitch();
  143   1          CanSetBaudrate();
  144   1          CanWriteReg(MR, 0x05);                     // Ê¹ÄÜResetÄ£Ê½£¬´ò¿ªË«ÂË²¨Æ÷¹¦ÄÜ
  145   1          CanWriteReg(ACR0, (u8)(User_Can_ID >> 3)); // ×ÜÏßÑéÊÕ´úÂë¼Ä´æÆ÷,¹ýÂËÉè±¸IDºÍ¹ã²¥ID
  146   1          CanWriteReg(ACR1, (u8)(User_Can_ID << 5));
  147   1          CanWriteReg(ACR2, 0x00); // ¹ã²¥µØÖ·Ä¬ÈÏÎª0£¬²»ÐèÒª¸ü¸Ä
  148   1          CanWriteReg(ACR3, 0x00);
  149   1      
  150   1          CanWriteReg(AMR0, 0x00); // ×ÜÏßÑéÊÕÆÁ±Î¼Ä´æÆ÷£¬Êý¾ÝÎ»²»Ð£Ñé£¬RTR²»Ð£Ñé
  151   1          CanWriteReg(AMR1, 0x1f);
  152   1          CanWriteReg(AMR2, 0x00);
  153   1          CanWriteReg(AMR3, 0x1f);
  154   1      
  155   1          CanWriteReg(ISR, 0xff); // ÇåÖÐ¶Ï±êÖ¾
  156   1          CanWriteReg(IMR, 0xff); // ÖÐ¶Ï¼Ä´æÆ÷ÉèÖÃ,ÏìÓ¦ËùÓÐÖÐ¶Ï
  157   1          CanWriteReg(MR, 0x00);  // ÍË³ö Reset Mode
  158   1          CANICR |= 0x02;         // CAN1ÖÐ¶ÏÊ¹ÄÜ
  159   1      }
  160          
  161          void CANBUS1_Interrupt(void) interrupt CAN1_VECTOR
  162          {
  163   1          u8 isr;
  164   1          u8 store;
  165   1          u8 arTemp;
  166   1      
  167   1          arTemp = CANAR; // ÏÈCANARÏÖ³¡±£´æ£¬±ÜÃâÖ÷Ñ­»·ÀïÐ´Íê CANAR ºó²úÉúÖÐ¶Ï£¬ÔÚÖÐ¶ÏÀïÐÞ¸ÄÁË CANAR ÄÚÈÝ
  168   1          store = AUXR2;  // ºóAUXR2ÏÖ³¡±£´æ
  169   1      
  170   1          AUXR2 &= ~0x08; // Ñ¡ÔñCAN1Ä£¿é
  171   1          isr = CanReadReg(ISR);
  172   1      
  173   1          if ((isr & 0x04) == 0x04) // TI
  174   1          {
  175   2              CANAR = ISR;
  176   2              CANDR = 0x04; // CLR FLAG
  177   2      
  178   2              B_Can1Send = 0;
  179   2          }
  180   1          if ((isr & 0x08) == 0x08) // RI
  181   1          {
  182   2              CANAR = ISR;
  183   2              CANDR = 0x08; // CLR FLAG
  184   2      
  185   2              B_Can1Read = 1;
C251 COMPILER V5.60.0,  can                                                                11/07/24  00:41:03  PAGE 4   

  186   2          }
  187   1      
  188   1          if ((isr & 0x40) == 0x40) // ALI
  189   1          {
  190   2              CANAR = ISR;
  191   2              CANDR = 0x40; // CLR FLAG
  192   2          }
  193   1      
  194   1          if ((isr & 0x20) == 0x20) // EWI
  195   1          {
  196   2              CANAR = MR;
  197   2              CANDR &= ~0x04; // Çå³ý Reset Mode, ´ÓBUS-OFF×´Ì¬ÍË³ö
  198   2      
  199   2              CANAR = ISR;
  200   2              CANDR = 0x20; // CLR FLAG
  201   2          }
  202   1      
  203   1          if ((isr & 0x10) == 0x10) // EPI
  204   1          {
  205   2              CANAR = ISR;
  206   2              CANDR = 0x10; // CLR FLAG
  207   2          }
  208   1      
  209   1          if ((isr & 0x02) == 0x02) // BEI
  210   1          {
  211   2              CANAR = ISR;
  212   2              CANDR = 0x02; // CLR FLAG
  213   2          }
  214   1      
  215   1          if ((isr & 0x01) == 0x01) // DOI
  216   1          {
  217   2              CANAR = ISR;
  218   2              CANDR = 0x01; // CLR FLAG
  219   2          }
  220   1      
  221   1          AUXR2 = store;  // ÏÈAUXR2ÏÖ³¡»Ö¸´
  222   1          CANAR = arTemp; // ºóCANARÏÖ³¡»Ö¸´
  223   1      }
  224          
  225          int camera_dat_l, camera_dat_r;
  226          u8 camera_state_l, camera_state_r;
  227          
  228          long read_left_postion, read_right_postion;
  229          
  230          void Can_Dat_Handle(CAN_DataDef *can_dat)
  231          {
  232   1          if (can_dat->DLC == 5) // ÅÐ¶¨Îª·µ»ØµÄÂÖ±ßÊý¾Ý
  233   1          {
  234   2              if (can_dat->ID == User_Can_ID)
  235   2              {
  236   3                  if (can_dat->DataBuffer[4] == 3) // ×óÂÖ
  237   3                  {
  238   4                      read_left_postion = (long)((u32)can_dat->DataBuffer[0] << 24 | (u32)can_dat->DataBuffer[1
             -] << 16 | (u32)can_dat->DataBuffer[2] << 8 | (u32)can_dat->DataBuffer[3]);
  239   4                  }
  240   3                  if (can_dat->DataBuffer[4] == 2) // ÓÒÂÖ
  241   3                  {
  242   4                      read_right_postion = (long)((u32)can_dat->DataBuffer[0] << 24 | (u32)can_dat->DataBuffer[
             -1] << 16 | (u32)can_dat->DataBuffer[2] << 8 | (u32)can_dat->DataBuffer[3]);
  243   4                  }
  244   3              }
  245   2          }
  246   1          if (can_dat->DLC == 3) // Êý¾Ý³¤¶È±ØÐëÊÇ1,fifoÆµÂÊ³¬³öÁË¾Í²»½ÓÊÕ¿ØÖÆÁË
  247   1          {
  248   2              if (can_dat->ID == User_Can_ID) // ID¹ýÂË,Á¢¿ÌÉúÐ§
  249   2              {
C251 COMPILER V5.60.0,  can                                                                11/07/24  00:41:03  PAGE 5   

  250   3                  if (can_dat->DataBuffer[2] & 0x80)
  251   3                  {
  252   4                      // LEFT
  253   4                      camera_dat_l = (int)can_dat->DataBuffer[0] << 8 | (int)can_dat->DataBuffer[1];
  254   4                      camera_state_l = (u8)can_dat->DataBuffer[2] & 0x7f;
  255   4                  }
  256   3                  else
  257   3                  {
  258   4                      camera_dat_r = (int)can_dat->DataBuffer[0] << 8 | (int)can_dat->DataBuffer[1];
  259   4                      camera_state_r = (u8)can_dat->DataBuffer[2] & 0x7f;
  260   4                  }
  261   3              }
  262   2          }
  263   1      }
  264          
  265          
  266          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1484     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       131         15
  bit size             =         2     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
