C251 COMPILER V5.60.0,  bno08x                                                             11/07/24  00:41:03  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE bno08x
OBJECT MODULE PLACED IN .\Objects\bno08x.obj
COMPILER INVOKED BY: C:\Keil\C251\BIN\C251.EXE User_Group\bno08x.c XSMALL BROWSE INCDIR(.\H_Group;.\User_Group) DEBUG PR
                    -INT(.\Listings\bno08x.lst) TABS(2) OBJECT(.\Objects\bno08x.obj) 

stmt  level    source

    1          #include "./H_Group/bno08x.h"
    2          void _delay(unsigned int t) //@24.000MHz
    3          {
    4   1          unsigned long edata i;
    5   1          for (; t > 0; t--)
    6   1          {
    7   2              _nop_();
    8   2              _nop_();
    9   2              _nop_();
   10   2              i = 12998UL;
   11   2              while (i)
   12   2                  i--;
   13   2          }
   14   1      }
   15          
   16          // Global Variables
   17          unsigned char shtpHeader[4]; // Each packet has a header of 4 chars
   18          unsigned char shtpData[MAX_PACKET_SIZE];
   19          unsigned char sequenceNumber[6] = {0, 0, 0, 0, 0, 0}; // There are 6 com channels. Each channel has its o
             -wn seqnum
   20          unsigned char commandSequenceNumber = 0;              // Commands have a seqNum as well. These are inside
             - command packet, the header uses its own seqNum per channel
   21          unsigned long metaData[MAX_METADATA_SIZE];            // There is more than 10 words in a metadata record
             - but we'll stop at Q point 3
   22          // Variables
   23          unsigned char _deviceAddress; // 跟踪 I2C 地址。setI2CAddress 更改了这一点。
   24          
   25          // These are the raw sensor values pulled from the user requested Input Report
   26          unsigned int rawAccelX, rawAccelY, rawAccelZ, accelAccuracy;
   27          unsigned int rawLinAccelX, rawLinAccelY, rawLinAccelZ, accelLinAccuracy;
   28          unsigned int rawGyroX, rawGyroY, rawGyroZ, gyroAccuracy;
   29          unsigned int rawMagX, rawMagY, rawMagZ, magAccuracy;
   30          unsigned int rawQuatI, rawQuatJ, rawQuatK, rawQuatReal, rawQuatRadianAccuracy, quatAccuracy;
   31          unsigned int stepCount;
   32          unsigned char stabilityClassifier;
   33          unsigned char activityClassifier;
   34          unsigned char *_activityConfidences; // Array that store the confidences of the 9 possible activities
   35          
   36          // These Q values are defined in the datasheet but can also be obtained by querying the meta data records
   37          // See the read metadata example for more info
   38          int rotationVector_Q1 = 14;
   39          int accelerometer_Q1 = 8;
   40          int linear_accelerometer_Q1 = 8;
   41          int gyro_Q1 = 9;
   42          int magnetometer_Q1 = 4;
   43          
   44          char dataAvailable(void)
   45          {
   46   1          if (receivePacket() == 1)
   47   1          {
   48   2              // Check to see if this packet is a sensor reporting its data to us
   49   2              if (shtpHeader[2] == CHANNEL_REPORTS && shtpData[0] == SHTP_REPORT_BASE_TIMESTAMP)
   50   2              {
   51   3                  parseInputReport(); // This will update the rawAccelX, etc variables depending on which featu
             -re report is found
   52   3                  return (1);
   53   3              }
   54   2          }
C251 COMPILER V5.60.0,  bno08x                                                             11/07/24  00:41:03  PAGE 2   

   55   1          return (0);
   56   1      }
   57          
   58          // This function pulls the data from the input report
   59          // The input reports vary in length so this function stores the various 16-bit values as globals
   60          
   61          // Unit responds with packet that contains the following:
   62          // shtpHeader[0:3]: First, a 4 byte header
   63          // shtpData[0:4]: Then a 5 byte timestamp of microsecond clicks since reading was taken
   64          // shtpData[5 + 0]: Then a feature report ID (0x01 for Accel, 0x05 for Rotation Vector)
   65          // shtpData[5 + 1]: Sequence number (See 6.5.18.2)
   66          // shtpData[5 + 2]: Status
   67          // shtpData[3]: _delay
   68          // shtpData[4:5]: i/accel x/gyro x/etc
   69          // shtpData[6:7]: j/accel y/gyro y/etc
   70          // shtpData[8:9]: k/accel z/gyro z/etc
   71          // shtpData[10:11]: real/gyro temp/etc
   72          // shtpData[12:13]: Accuracy estimate
   73          void parseInputReport(void)
   74          {
   75   1          // Calculate the number of data bytes in this packet
   76   1          int dataLength = ((unsigned int)shtpHeader[1] << 8 | shtpHeader[0]);
   77   1      
   78   1          unsigned char status = shtpData[5 + 2] & 0x03; // Get status bits
   79   1          unsigned int data1 = (unsigned int)shtpData[5 + 5] << 8 | shtpData[5 + 4];
   80   1          unsigned int data2 = (unsigned int)shtpData[5 + 7] << 8 | shtpData[5 + 6];
   81   1          unsigned int data3 = (unsigned int)shtpData[5 + 9] << 8 | shtpData[5 + 8];
   82   1          unsigned int data4 = 0;
   83   1          unsigned int data5 = 0;
   84   1          unsigned char x = 0;
   85   1          dataLength &= ~(1 << 15); // Clear the MSbit. This bit indicates if this package is a continuation of
             - the last.
   86   1          // Ignore it for now. TODO catch this as an error and exit
   87   1      
   88   1          dataLength -= 4; // Remove the header bytes from the data count
   89   1      
   90   1          if (dataLength - 5 > 9)
   91   1          {
   92   2              data4 = (unsigned int)shtpData[5 + 11] << 8 | shtpData[5 + 10];
   93   2          }
   94   1          if (dataLength - 5 > 11)
   95   1          {
   96   2              data5 = (unsigned int)shtpData[5 + 13] << 8 | shtpData[5 + 12];
   97   2          }
   98   1      
   99   1          // Store these generic values to their proper global variable
  100   1          if (shtpData[5] == SENSOR_REPORTID_ACCELEROMETER)
  101   1          {
  102   2              accelAccuracy = status;
  103   2              rawAccelX = data1;
  104   2              rawAccelY = data2;
  105   2              rawAccelZ = data3;
  106   2          }
  107   1          else if (shtpData[5] == SENSOR_REPORTID_LINEAR_ACCELERATION)
  108   1          {
  109   2              accelLinAccuracy = status;
  110   2              rawLinAccelX = data1;
  111   2              rawLinAccelY = data2;
  112   2              rawLinAccelZ = data3;
  113   2          }
  114   1          else if (shtpData[5] == SENSOR_REPORTID_GYROSCOPE)
  115   1          {
  116   2              gyroAccuracy = status;
  117   2              rawGyroX = data1;
  118   2              rawGyroY = data2;
  119   2              rawGyroZ = data3;
C251 COMPILER V5.60.0,  bno08x                                                             11/07/24  00:41:03  PAGE 3   

  120   2          }
  121   1          else if (shtpData[5] == SENSOR_REPORTID_MAGNETIC_FIELD)
  122   1          {
  123   2              magAccuracy = status;
  124   2              rawMagX = data1;
  125   2              rawMagY = data2;
  126   2              rawMagZ = data3;
  127   2          }
  128   1          else if (shtpData[5] == SENSOR_REPORTID_ROTATION_VECTOR || shtpData[5] == SENSOR_REPORTID_GAME_ROTATI
             -ON_VECTOR)
  129   1          {
  130   2              quatAccuracy = status;
  131   2              rawQuatI = data1;
  132   2              rawQuatJ = data2;
  133   2              rawQuatK = data3;
  134   2              rawQuatReal = data4;
  135   2              rawQuatRadianAccuracy = data5; // Only available on rotation vector, not game rot vector
  136   2          }
  137   1          else if (shtpData[5] == SENSOR_REPORTID_STEP_COUNTER)
  138   1          {
  139   2              stepCount = data3; // Bytes 8/9
  140   2          }
  141   1          else if (shtpData[5] == SENSOR_REPORTID_STABILITY_CLASSIFIER)
  142   1          {
  143   2              stabilityClassifier = shtpData[5 + 4]; // Byte 4 only
  144   2          }
  145   1          else if (shtpData[5] == SENSOR_REPORTID_PERSONAL_ACTIVITY_CLASSIFIER)
  146   1          {
  147   2              activityClassifier = shtpData[5 + 5]; // Most likely state
  148   2      
  149   2              // Load activity classification confidences into the array
  150   2              for (x = 0; x < 9; x++)                            // Hardcoded to max of 9. TODO - bring in arra
             -y size
  151   2                  _activityConfidences[x] = shtpData[5 + 6 + x]; // 5 bytes of timestamp, byte 6 is first confi
             -dence byte
  152   2          }
  153   1          else
  154   1          {
  155   2              // This sensor report ID is unhandled.
  156   2              // See reference manual to add additional feature reports as needed
  157   2          }
  158   1      
  159   1          // TODO additional feature reports may be strung together. Parse them all.
  160   1      }
  161          
  162          // Return the rotation vector quaternion I
  163          float getQuatI()
  164          {
  165   1          float quat = qToFloat(rawQuatI, (unsigned char)rotationVector_Q1);
  166   1          return (quat);
  167   1      }
  168          
  169          // Return the rotation vector quaternion J
  170          float getQuatJ()
  171          {
  172   1          float quat = qToFloat(rawQuatJ, (unsigned char)rotationVector_Q1);
  173   1          return (quat);
  174   1      }
  175          
  176          // Return the rotation vector quaternion K
  177          float getQuatK()
  178          {
  179   1          float quat = qToFloat(rawQuatK, (unsigned char)rotationVector_Q1);
  180   1          return (quat);
  181   1      }
  182          
C251 COMPILER V5.60.0,  bno08x                                                             11/07/24  00:41:03  PAGE 4   

  183          // Return the rotation vector quaternion Real
  184          float getQuatReal()
  185          {
  186   1          float quat = qToFloat(rawQuatReal, (unsigned char)rotationVector_Q1);
  187   1          return (quat);
  188   1      }
  189          
  190          // Return the rotation vector accuracy
  191          float getQuatRadianAccuracy()
  192          {
  193   1          float quat = qToFloat(rawQuatRadianAccuracy, (unsigned char)rotationVector_Q1);
  194   1          return (quat);
  195   1      }
  196          
  197          // Return the acceleration component
  198          unsigned char getQuatAccuracy()
  199          {
  200   1          return (quatAccuracy);
  201   1      }
  202          
  203          // Return the acceleration component
  204          float getAccelX()
  205          {
  206   1          float accel = qToFloat(rawAccelX, (unsigned char)accelerometer_Q1);
  207   1          return (accel);
  208   1      }
  209          
  210          // Return the acceleration component
  211          float getAccelY()
  212          {
  213   1          float accel = qToFloat(rawAccelY, (unsigned char)accelerometer_Q1);
  214   1          return (accel);
  215   1      }
  216          
  217          // Return the acceleration component
  218          float getAccelZ()
  219          {
  220   1          float accel = qToFloat(rawAccelZ, (unsigned char)accelerometer_Q1);
  221   1          return (accel);
  222   1      }
  223          
  224          // Return the acceleration component
  225          unsigned char getAccelAccuracy()
  226          {
  227   1          return (accelAccuracy);
  228   1      }
  229          
  230          // linear acceleration, i.e. minus gravity
  231          
  232          // Return the acceleration component
  233          float getLinAccelX()
  234          {
  235   1          float accel = qToFloat(rawLinAccelX, (unsigned char)linear_accelerometer_Q1);
  236   1          return (accel);
  237   1      }
  238          
  239          // Return the acceleration component
  240          float getLinAccelY()
  241          {
  242   1          float accel = qToFloat(rawLinAccelY, (unsigned char)linear_accelerometer_Q1);
  243   1          return (accel);
  244   1      }
  245          
  246          // Return the acceleration component
  247          float getLinAccelZ()
  248          {
C251 COMPILER V5.60.0,  bno08x                                                             11/07/24  00:41:03  PAGE 5   

  249   1          float accel = qToFloat(rawLinAccelZ, (unsigned char)linear_accelerometer_Q1);
  250   1          return (accel);
  251   1      }
  252          
  253          // Return the acceleration component
  254          unsigned char getLinAccelAccuracy()
  255          {
  256   1          return (accelLinAccuracy);
  257   1      }
  258          
  259          // Return the gyro component
  260          float getGyroX()
  261          {
  262   1          float gyro = qToFloat(rawGyroX, (unsigned char)gyro_Q1);
  263   1          return (gyro);
  264   1      }
  265          
  266          // Return the gyro component
  267          float getGyroY()
  268          {
  269   1          float gyro = qToFloat(rawGyroY, (unsigned char)gyro_Q1);
  270   1          return (gyro);
  271   1      }
  272          
  273          // Return the gyro component
  274          float getGyroZ()
  275          {
  276   1          float gyro = qToFloat(rawGyroZ, (unsigned char)gyro_Q1);
  277   1          return (gyro);
  278   1      }
  279          
  280          // Return the gyro component
  281          unsigned char getGyroAccuracy()
  282          {
  283   1          return (gyroAccuracy);
  284   1      }
  285          
  286          // Return the magnetometer component
  287          float getMagX()
  288          {
  289   1          float mag = qToFloat(rawMagX, (unsigned char)magnetometer_Q1);
  290   1          return (mag);
  291   1      }
  292          
  293          // Return the magnetometer component
  294          float getMagY()
  295          {
  296   1          float mag = qToFloat(rawMagY, (unsigned char)magnetometer_Q1);
  297   1          return (mag);
  298   1      }
  299          
  300          // Return the magnetometer component
  301          float getMagZ()
  302          {
  303   1          float mag = qToFloat(rawMagZ, (unsigned char)magnetometer_Q1);
  304   1          return (mag);
  305   1      }
  306          
  307          // Return the mag component
  308          unsigned char getMagAccuracy()
  309          {
  310   1          return (magAccuracy);
  311   1      }
  312          
  313          // Return the step count
  314          unsigned int getStepCount()
C251 COMPILER V5.60.0,  bno08x                                                             11/07/24  00:41:03  PAGE 6   

  315          {
  316   1          return (stepCount);
  317   1      }
  318          
  319          // Return the stability classifier
  320          unsigned char getStabilityClassifier()
  321          {
  322   1          return (stabilityClassifier);
  323   1      }
  324          
  325          // Return the activity classifier
  326          unsigned char getActivityClassifier()
  327          {
  328   1          return (activityClassifier);
  329   1      }
  330          
  331          // Given a record ID, read the Q1 value from the metaData record in the FRS (ya, it's complicated)
  332          // Q1 is used for all sensor data calculations
  333          int getQ1(unsigned int recordID)
  334          {
  335   1          // Q1 is always the lower 16 bits of word 7
  336   1          unsigned int q = readFRSword(recordID, 7) & 0xFFFF; // Get word 7, lower 16 bits
  337   1          return (q);
  338   1      }
  339          
  340          // Given a record ID, read the Q2 value from the metaData record in the FRS
  341          // Q2 is used in sensor bias
  342          int getQ2(unsigned int recordID)
  343          {
  344   1          // Q2 is always the upper 16 bits of word 7
  345   1          unsigned int q = readFRSword(recordID, 7) >> 16; // Get word 7, upper 16 bits
  346   1          return (q);
  347   1      }
  348          
  349          // Given a record ID, read the Q3 value from the metaData record in the FRS
  350          // Q3 is used in sensor change sensitivity
  351          int getQ3(unsigned int recordID)
  352          {
  353   1          // Q3 is always the upper 16 bits of word 8
  354   1          unsigned int q = readFRSword(recordID, 8) >> 16; // Get word 8, upper 16 bits
  355   1          return (q);
  356   1      }
  357          
  358          // Given a record ID, read the resolution value from the metaData record in the FRS for a given sensor
  359          float getResolution(unsigned int recordID)
  360          {
  361   1          // The resolution Q value are 'the same as those used in the sensor's input report'
  362   1          // This should be Q1.
  363   1          int Q = getQ1(recordID);
  364   1      
  365   1          // Resolution is always word 2
  366   1          unsigned long value = readFRSword(recordID, 2); // Get word 2
  367   1      
  368   1          float resolution = qToFloat((unsigned int)value, (unsigned char)Q);
  369   1      
  370   1          return (resolution);
  371   1      }
  372          
  373          // Given a record ID, read the range value from the metaData record in the FRS for a given sensor
  374          float getRange(unsigned int recordID)
  375          {
  376   1          // The resolution Q value are 'the same as those used in the sensor's input report'
  377   1          // This should be Q1.
  378   1          int Q = getQ1(recordID);
  379   1      
  380   1          // Range is always word 1
C251 COMPILER V5.60.0,  bno08x                                                             11/07/24  00:41:03  PAGE 7   

  381   1          unsigned long value = readFRSword(recordID, 1); // Get word 1
  382   1      
  383   1          float range = qToFloat((unsigned int)value, (unsigned char)Q);
  384   1      
  385   1          return (range);
  386   1      }
  387          
  388          // Given a record ID and a word number, look up the word data
  389          // Helpful for pulling out a Q value, range, etc.
  390          // Use readFRSdata for pulling out multi-word objects for a sensor (Vendor data for example)
  391          unsigned long readFRSword(unsigned int recordID, unsigned char wordNumber)
  392          {
  393   1          if (readFRSdata(recordID, wordNumber, 1) == 1) // Get word number, just one word in length from FRS
  394   1              return (metaData[0]);                      // Return this one word
  395   1      
  396   1          return (0); // Error
  397   1      }
  398          
  399          // Ask the sensor for data from the Flash Record System
  400          // See 6.3.6 page 40, FRS Read Request
  401          void frsReadRequest(unsigned int recordID, unsigned int readOffset, unsigned int blockSize)
  402          {
  403   1          shtpData[0] = SHTP_REPORT_FRS_READ_REQUEST; // FRS Read Request
  404   1          shtpData[1] = 0;                            // Reserved
  405   1          shtpData[2] = (readOffset >> 0) & 0xFF;     // Read Offset LSB
  406   1          shtpData[3] = (readOffset >> 8) & 0xFF;     // Read Offset MSB
  407   1          shtpData[4] = (recordID >> 0) & 0xFF;       // FRS Type LSB
  408   1          shtpData[5] = (recordID >> 8) & 0xFF;       // FRS Type MSB
  409   1          shtpData[6] = (blockSize >> 0) & 0xFF;      // Block size LSB
  410   1          shtpData[7] = (blockSize >> 8) & 0xFF;      // Block size MSB
  411   1      
  412   1          // Transmit packet on channel 2, 8 bytes
  413   1          sendPacket(CHANNEL_CONTROL, 8);
  414   1      }
  415          
  416          // Given a sensor or record ID, and a given start/stop bytes, read the data from the Flash Record System 
             -(FRS) for this sensor
  417          // Returns 1 if metaData array is loaded successfully
  418          // Returns 0 if failure
  419          char readFRSdata(unsigned int recordID, unsigned char startLocation, unsigned char wordsToRead)
  420          {
  421   1          unsigned char spot = 0;
  422   1          unsigned char dataLength = 0;
  423   1          unsigned char frsStatus = 0;
  424   1          unsigned long data0 = 0;
  425   1          unsigned long data1 = 0;
  426   1          // First we send a Flash Record System (FRS) request
  427   1          frsReadRequest(recordID, startLocation, wordsToRead); // From startLocation of record, read a # of wo
             -rds
  428   1      
  429   1          // Read bytes until FRS reports that the read is complete
  430   1          while (1)
  431   1          {
  432   2              // Now we wait for response
  433   2              while (1)
  434   2              {
  435   3                  unsigned char counter = 0;
  436   3                  while (receivePacket() == 0)
  437   3                  {
  438   4                      if (counter++ > 100)
  439   4                          return (0); // Give up
  440   4                      _delay(1);
  441   4                  }
  442   3      
  443   3                  // We have the packet, inspect it for the right contents
  444   3                  // See page 40. Report ID should be 0xF3 and the FRS types should match the thing we requeste
C251 COMPILER V5.60.0,  bno08x                                                             11/07/24  00:41:03  PAGE 8   

             -d
  445   3                  if (shtpData[0] == SHTP_REPORT_FRS_READ_RESPONSE)
  446   3                      if (((unsigned int)shtpData[13] << 8 | shtpData[12]) == recordID)
  447   3                          break; // This packet is one we are looking for
  448   3              }
  449   2      
  450   2              dataLength = shtpData[1] >> 4;
  451   2              frsStatus = shtpData[1] & 0x0F;
  452   2      
  453   2              data0 = (unsigned long)shtpData[7] << 24 | (unsigned long)shtpData[6] << 16 | (unsigned long)shtp
             -Data[5] << 8 | (unsigned long)shtpData[4];
  454   2              data1 = (unsigned long)shtpData[11] << 24 | (unsigned long)shtpData[10] << 16 | (unsigned long)sh
             -tpData[9] << 8 | (unsigned long)shtpData[8];
  455   2      
  456   2              // Record these words to the metaData array
  457   2              if (dataLength > 0)
  458   2              {
  459   3                  metaData[spot++] = data0;
  460   3              }
  461   2              if (dataLength > 1)
  462   2              {
  463   3                  metaData[spot++] = data1;
  464   3              }
  465   2      
  466   2              if (frsStatus == 3 || frsStatus == 6 || frsStatus == 7)
  467   2              {
  468   3                  return (1); // FRS status is read completed! We're done!
  469   3              }
  470   2          }
  471   1      }
  472          
  473          //发送命令复位IC
  474          //从传感器读取所有通告数据包
  475          //如果我们尝试太多太快，传感器会重置两次。
  476          //这似乎可靠地工作。
  477          void softReset(void)
  478          {
  479   1          shtpData[0] = 1; // Reset
  480   1      
  481   1          // Attempt to start communication with sensor
  482   1          sendPacket(CHANNEL_EXECUTABLE, 1); // Transmit packet on channel 1, 1 byte
  483   1      
  484   1          // Read all incoming data and flush it
  485   1          _delay(50);
  486   1          while (receivePacket() == 1)
  487   1              ;
  488   1          _delay(50);
  489   1          while (receivePacket() == 1)
  490   1              ;
  491   1      }
  492          
  493          // Get the reason for the last reset
  494          // 1 = POR, 2 = Internal reset, 3 = Watchdog, 4 = External reset, 5 = Other
  495          unsigned char resetReason()
  496          {
  497   1          shtpData[0] = SHTP_REPORT_PRODUCT_ID_REQUEST; // Request the product ID and reset info
  498   1          shtpData[1] = 0;                              // Reserved
  499   1      
  500   1          // Transmit packet on channel 2, 2 bytes
  501   1          sendPacket(CHANNEL_CONTROL, 2);
  502   1      
  503   1          // Now we wait for response
  504   1          if (receivePacket() == 1)
  505   1          {
  506   2              if (shtpData[0] == SHTP_REPORT_PRODUCT_ID_RESPONSE)
  507   2              {
C251 COMPILER V5.60.0,  bno08x                                                             11/07/24  00:41:03  PAGE 9   

  508   3                  return (shtpData[1]);
  509   3              }
  510   2          }
  511   1      
  512   1          return (0);
  513   1      }
  514          
  515          // Given a register value and a Q point, convert to float
  516          // See https://en.wikipedia.org/wiki/Q_(number_format)
  517          float qToFloat(int fixedPointValue, unsigned char qPoint)
  518          {
  519   1          float qFloat = fixedPointValue;
  520   1          qFloat *= pow(2, qPoint * -1);
  521   1          return (qFloat);
  522   1      }
  523          
  524          // Sends the packet to enable the rotation vector
  525          void enableRotationVector(unsigned int timeBetweenReports)
  526          {
  527   1          setFeatureCommand(SENSOR_REPORTID_ROTATION_VECTOR, timeBetweenReports, 0);
  528   1      }
  529          
  530          void enableFast_RotationVector(unsigned int timeBetweenReports)
  531          {
  532   1          setFeatureCommand(SENSOR_REPORTID_GYRO_INTEGRATED_ROTATION_VECTOR, timeBetweenReports, 0);
  533   1      }
  534          
  535          // Sends the packet to enable the rotation vector
  536          void enableGameRotationVector(unsigned int timeBetweenReports)
  537          {
  538   1          setFeatureCommand(SENSOR_REPORTID_GAME_ROTATION_VECTOR, timeBetweenReports, 0);
  539   1      }
  540          
  541          // Sends the packet to enable the accelerometer
  542          void enableAccelerometer(unsigned int timeBetweenReports)
  543          {
  544   1          setFeatureCommand(SENSOR_REPORTID_ACCELEROMETER, timeBetweenReports, 0);
  545   1      }
  546          
  547          // Sends the packet to enable the accelerometer
  548          void enableLinearAccelerometer(unsigned int timeBetweenReports)
  549          {
  550   1          setFeatureCommand(SENSOR_REPORTID_LINEAR_ACCELERATION, timeBetweenReports, 0);
  551   1      }
  552          
  553          // Sends the packet to enable the gyro
  554          void enableGyro(unsigned int timeBetweenReports)
  555          {
  556   1          setFeatureCommand(SENSOR_REPORTID_GYROSCOPE, timeBetweenReports, 0);
  557   1      }
  558          
  559          // Sends the packet to enable the magnetometer
  560          void enableMagnetometer(unsigned int timeBetweenReports)
  561          {
  562   1          setFeatureCommand(SENSOR_REPORTID_MAGNETIC_FIELD, timeBetweenReports, 0);
  563   1      }
  564          
  565          // Sends the packet to enable the step counter
  566          void enableStepCounter(unsigned int timeBetweenReports)
  567          {
  568   1          setFeatureCommand(SENSOR_REPORTID_STEP_COUNTER, timeBetweenReports, 0);
  569   1      }
  570          
  571          // Sends the packet to enable the Stability Classifier
  572          void enableStabilityClassifier(unsigned int timeBetweenReports)
  573          {
C251 COMPILER V5.60.0,  bno08x                                                             11/07/24  00:41:03  PAGE 10  

  574   1          setFeatureCommand(SENSOR_REPORTID_STABILITY_CLASSIFIER, timeBetweenReports, 0);
  575   1      }
  576          
  577          // Sends the commands to begin calibration of the accelerometer
  578          void calibrateAccelerometer()
  579          {
  580   1          sendCalibrateCommand(CALIBRATE_ACCEL);
  581   1      }
  582          
  583          // Sends the commands to begin calibration of the gyro
  584          void calibrateGyro()
  585          {
  586   1          sendCalibrateCommand(CALIBRATE_GYRO);
  587   1      }
  588          
  589          // Sends the commands to begin calibration of the magnetometer
  590          void calibrateMagnetometer()
  591          {
  592   1          sendCalibrateCommand(CALIBRATE_MAG);
  593   1      }
  594          
  595          // Sends the commands to begin calibration of the planar accelerometer
  596          void calibratePlanarAccelerometer()
  597          {
  598   1          sendCalibrateCommand(CALIBRATE_PLANAR_ACCEL);
  599   1      }
  600          
  601          // See 2.2 of the Calibration Procedure document 1000-4044
  602          void calibrateAll()
  603          {
  604   1          sendCalibrateCommand(CALIBRATE_ACCEL_GYRO_MAG);
  605   1      }
  606          
  607          void endCalibration()
  608          {
  609   1          sendCalibrateCommand(CALIBRATE_STOP); // Disables all calibrations
  610   1      }
  611          
  612          // Given a sensor's report ID, this tells the BNO080 to begin reporting the values
  613          // Also sets the specific config word. Useful for personal activity classifier
  614          void setFeatureCommand(unsigned char reportID, unsigned int timeBetweenReports, unsigned long specificCon
             -fig)
  615          {
  616   1          long microsBetweenReports = (long)timeBetweenReports;
  617   1      
  618   1          shtpData[0] = SHTP_REPORT_SET_FEATURE_COMMAND;     // Set feature command. Reference page 55
  619   1          shtpData[1] = reportID;                            // Feature Report ID. 0x01 = Accelerometer, 0x05 =
             - Rotation vector
  620   1          shtpData[2] = 0;                                   // Feature flags
  621   1          shtpData[3] = 0;                                   // Change sensitivity (LSB)
  622   1          shtpData[4] = 0;                                   // Change sensitivity (MSB)
  623   1          shtpData[5] = (microsBetweenReports >> 0) & 0xFF;  // Report interval (LSB) in microseconds. 0x7A120 
             -= 500ms
  624   1          shtpData[6] = (microsBetweenReports >> 8) & 0xFF;  // Report interval
  625   1          shtpData[7] = (microsBetweenReports >> 16) & 0xFF; // Report interval
  626   1          shtpData[8] = (microsBetweenReports >> 24) & 0xFF; // Report interval (MSB)
  627   1          shtpData[9] = 0;                                   // Batch Interval (LSB)
  628   1          shtpData[10] = 0;                                  // Batch Interval
  629   1          shtpData[11] = 0;                                  // Batch Interval
  630   1          shtpData[12] = 0;                                  // Batch Interval (MSB)
  631   1          shtpData[13] = (specificConfig >> 0) & 0xFF;       // Sensor-specific config (LSB)
  632   1          shtpData[14] = (specificConfig >> 8) & 0xFF;       // Sensor-specific config
  633   1          shtpData[15] = (specificConfig >> 16) & 0xFF;      // Sensor-specific config
  634   1          shtpData[16] = (specificConfig >> 24) & 0xFF;      // Sensor-specific config (MSB)
  635   1      
  636   1          // Transmit packet on channel 2, 17 bytes
C251 COMPILER V5.60.0,  bno08x                                                             11/07/24  00:41:03  PAGE 11  

  637   1          sendPacket(CHANNEL_CONTROL, 17);
  638   1      }
  639          
  640          // Tell the sensor to do a command
  641          // See 6.3.8 page 41, Command request
  642          // The caller is expected to set P0 through P8 prior to calling
  643          void sendCommand(unsigned char command)
  644          {
  645   1          shtpData[0] = SHTP_REPORT_COMMAND_REQUEST; // Command Request
  646   1          shtpData[1] = commandSequenceNumber++;     // Increments automatically each function call
  647   1          shtpData[2] = command;                     // Command
  648   1      
  649   1          // Caller must set these
  650   1          /*shtpData[3] = 0; //P0
  651   1          shtpData[4] = 0; //P1
  652   1          shtpData[5] = 0; //P2
  653   1          shtpData[6] = 0;
  654   1          shtpData[7] = 0;
  655   1          shtpData[8] = 0;
  656   1          shtpData[9] = 0;
  657   1          shtpData[10] = 0;
  658   1          shtpData[11] = 0;*/
  659   1      
  660   1          // Transmit packet on channel 2, 12 bytes
  661   1          sendPacket(CHANNEL_CONTROL, 12);
  662   1      }
  663          
  664          // This tells the BNO080 to begin calibrating
  665          // See page 50 of reference manual and the 1000-4044 calibration doc
  666          void sendCalibrateCommand(unsigned char thingToCalibrate)
  667          {
  668   1          unsigned char x = 0;
  669   1          /*shtpData[3] = 0; //P0 - Accel Cal Enable
  670   1          shtpData[4] = 0; //P1 - Gyro Cal Enable
  671   1          shtpData[5] = 0; //P2 - Mag Cal Enable
  672   1          shtpData[6] = 0; //P3 - Subcommand 0x00
  673   1          shtpData[7] = 0; //P4 - Planar Accel Cal Enable
  674   1          shtpData[8] = 0; //P5 - Reserved
  675   1          shtpData[9] = 0; //P6 - Reserved
  676   1          shtpData[10] = 0; //P7 - Reserved
  677   1          shtpData[11] = 0; //P8 - Reserved*/
  678   1      
  679   1          for (x = 3; x < 12; x++) // Clear this section of the shtpData array
  680   1              shtpData[x] = 0;
  681   1      
  682   1          if (thingToCalibrate == CALIBRATE_ACCEL)
  683   1              shtpData[3] = 1;
  684   1          else if (thingToCalibrate == CALIBRATE_GYRO)
  685   1              shtpData[4] = 1;
  686   1          else if (thingToCalibrate == CALIBRATE_MAG)
  687   1              shtpData[5] = 1;
  688   1          else if (thingToCalibrate == CALIBRATE_PLANAR_ACCEL)
  689   1              shtpData[7] = 1;
  690   1          else if (thingToCalibrate == CALIBRATE_ACCEL_GYRO_MAG)
  691   1          {
  692   2              shtpData[3] = 1;
  693   2              shtpData[4] = 1;
  694   2              shtpData[5] = 1;
  695   2          }
  696   1          else if (thingToCalibrate == CALIBRATE_STOP)
  697   1              ; // Do nothing, bytes are set to zero
  698   1      
  699   1          // Using this shtpData packet, send a command
  700   1          sendCommand(COMMAND_ME_CALIBRATE);
  701   1      }
  702          
C251 COMPILER V5.60.0,  bno08x                                                             11/07/24  00:41:03  PAGE 12  

  703          // This tells the BNO080 to save the Dynamic Calibration Data (DCD) to flash
  704          // See page 49 of reference manual and the 1000-4044 calibration doc
  705          void saveCalibration()
  706          {
  707   1          unsigned char x = 0;
  708   1          /*shtpData[3] = 0; //P0 - Reserved
  709   1          shtpData[4] = 0; //P1 - Reserved
  710   1          shtpData[5] = 0; //P2 - Reserved
  711   1          shtpData[6] = 0; //P3 - Reserved
  712   1          shtpData[7] = 0; //P4 - Reserved
  713   1          shtpData[8] = 0; //P5 - Reserved
  714   1          shtpData[9] = 0; //P6 - Reserved
  715   1          shtpData[10] = 0; //P7 - Reserved
  716   1          shtpData[11] = 0; //P8 - Reserved*/
  717   1      
  718   1          for (x = 3; x < 12; x++) // Clear this section of the shtpData array
  719   1              shtpData[x] = 0;
  720   1      
  721   1          // Using this shtpData packet, send a command
  722   1          sendCommand(COMMAND_DCD); // Save DCD command
  723   1      }
  724          
  725          void I2C_Init(void)
  726          {
  727   1          EAXFR = 1; // 扩展寄存器(XFR)访问使能
  728   1          I2C_S1 = 0; // I2C功能脚选择，00:P1.5,P1.4; 01:P2.5,P2.4; 11:P3.2,P3.3
  729   1          I2C_S0 = 1;
  730   1          I2CCFG = 0xe0 + 30; // 使能I2C主机模式
  731   1          I2CMSST = 0x00;
  732   1      }
  733          
  734          void Wait()
  735          {
  736   1          EAXFR = 1; // 扩展寄存器(XFR)访问使能
  737   1          while (!(I2CMSST & 0x40))
  738   1              ;
  739   1          I2CMSST &= ~0x40;
  740   1      }
  741          
  742          void Start()
  743          {
  744   1          I2CMSCR = 0x01; // 发送START命令
  745   1          Wait();
  746   1      }
  747          
  748          void SendData(char dat)
  749          {
  750   1          I2CTXD = dat;   // 写数据到数据缓冲区
  751   1          I2CMSCR = 0x02; // 发送SEND命令
  752   1          Wait();
  753   1      }
  754          
  755          void RecvACK()
  756          {
  757   1          I2CMSCR = 0x03; // 发送读ACK命令
  758   1          Wait();
  759   1      }
  760          
  761          char RecvData()
  762          {
  763   1          I2CMSCR = 0x04; // 发送RECV命令
  764   1          Wait();
  765   1          return I2CRXD;
  766   1      }
  767          
  768          void SendACK()
C251 COMPILER V5.60.0,  bno08x                                                             11/07/24  00:41:03  PAGE 13  

  769          {
  770   1          I2CMSST = 0x00; // 设置ACK信号
  771   1          I2CMSCR = 0x05; // 发送ACK命令
  772   1          Wait();
  773   1      }
  774          
  775          void SendNAK()
  776          {
  777   1          I2CMSST = 0x01; // 设置NAK信号
  778   1          I2CMSCR = 0x05; // 发送ACK命令
  779   1          Wait();
  780   1      }
  781          
  782          void Stop()
  783          {
  784   1          I2CMSCR = 0x06; // 发送STOP命令
  785   1          Wait();
  786   1      }
  787          
  788          #define SLAW 0x96
  789          #define SLAR 0x97
  790          
  791          void WriteNbyte(u8 *p, u8 number) /*  WordAddress,First Data Address,Byte lenth   */
  792          {
  793   1          Start();        // 发送起始命令
  794   1          SendData(SLAW); // 发送设备地址+写命令
  795   1          RecvACK();
  796   1          do
  797   1          {
  798   2              SendData(*p++);
  799   2              RecvACK();
  800   2          } while (--number);
  801   1          Stop(); // 发送停止命令
  802   1      }
  803          
  804          void ReadNbyte(u8 *p, u8 number) /*  WordAddress,First Data Address,Byte lenth   */
  805          {
  806   1          Start();        // 发送起始命令
  807   1          SendData(SLAR); // 发送设备地址+读命令
  808   1          RecvACK();
  809   1          do
  810   1          {
  811   2              *p = RecvData();
  812   2              p++;
  813   2              if (number != 1)
  814   2                  SendACK(); // send ACK
  815   2          } while (--number);
  816   1          SendNAK(); // send no ACK
  817   1          Stop();    // 发送停止命令
  818   1      }
  819          
  820          u8 i2c_tmp[32] = {0};
  821          
  822          // 检查是否有任何可用的新数据
  823          // 将传入数据包的内容读入 shtpData 数组
  824          char receivePacket(void)
  825          {
  826   1          int dataLength = 0;
  827   1          unsigned char packetLSB = 0;
  828   1          unsigned char packetMSB = 0;
  829   1          unsigned char channelNumber = 0;
  830   1          unsigned char sequenceNumber = 0;
  831   1          ReadNbyte(i2c_tmp, 4);
  832   1      
  833   1          // Get the first four bytes, aka the packet header
  834   1          packetLSB = i2c_tmp[0];
C251 COMPILER V5.60.0,  bno08x                                                             11/07/24  00:41:03  PAGE 14  

  835   1          packetMSB = i2c_tmp[1];
  836   1          channelNumber = i2c_tmp[2];
  837   1          sequenceNumber = i2c_tmp[3]; // Not sure if we need to store this or not
  838   1      
  839   1          // Store the header info.
  840   1          shtpHeader[0] = packetLSB;
  841   1          shtpHeader[1] = packetMSB;
  842   1          shtpHeader[2] = channelNumber;
  843   1          shtpHeader[3] = sequenceNumber;
  844   1      
  845   1          // Calculate the number of data bytes in this packet
  846   1          dataLength = ((unsigned int)packetMSB << 8 | packetLSB);
  847   1          dataLength &= ~(1 << 15); // 清除 MSbit。
  848   1          // 此位指示此包是否是上一个包的延续。暂时忽略它。
  849   1          // TODO 将此捕获为错误并退出
  850   1          if (dataLength == 0)
  851   1          {
  852   2              // Packet is empty
  853   2              return (0); // All done
  854   2          }
  855   1          dataLength -= 4; // Remove the header bytes from the data count
  856   1      
  857   1          getData(dataLength);
  858   1      
  859   1          return (1); // We're done!
  860   1      }
  861          
  862          // 向传感器发送多个请求，直到从传感器接收到所有数据字节
  863          // shtpData 缓冲区的最大容量为 MAX_PACKET_SIZE。超过此量的任何字节都将丢失。
  864          // Arduino I2C 读取限制为 32 字节。标头是 4 个字节，因此我们每个交互可以读取的最大数据为 28 字节
  865          char getData(unsigned int bytesRemaining)
  866          {
  867   1          unsigned int dataSpot = 0; // Start at the beginning of shtpData array
  868   1          unsigned char x = 0;
  869   1          unsigned char incoming = 0;
  870   1          // Setup a series of chunked 32 byte reads
  871   1          while (bytesRemaining > 0)
  872   1          {
  873   2              unsigned int numberOfBytesToRead = bytesRemaining;
  874   2              if (numberOfBytesToRead > (I2C_BUFFER_LENGTH - 4))
  875   2                  numberOfBytesToRead = (I2C_BUFFER_LENGTH - 4);
  876   2              ReadNbyte(i2c_tmp, (unsigned char)(numberOfBytesToRead + 4));
  877   2      
  878   2              // 前四个字节是标头字节，被丢弃
  879   2      
  880   2              for (x = 0; x < numberOfBytesToRead; x++)
  881   2              {
  882   3                  incoming = i2c_tmp[x + 4];
  883   3                  if (dataSpot < MAX_PACKET_SIZE)
  884   3                  {
  885   4                      shtpData[dataSpot++] = incoming; // Store data into the shtpData array
  886   4                  }
  887   3                  else
  888   3                  {
  889   4                      // Do nothing with the data
  890   4                  }
  891   3              }
  892   2      
  893   2              bytesRemaining -= numberOfBytesToRead;
  894   2          }
  895   1          return (1); // Done!
  896   1      }
  897          
  898          // 给定数据包，发送标头，然后发送数据
  899          // 如果传感器不 ACK，则返回 0
  900          // TODO - Arduino 的最大发送量为 32 字节。如果需要，将发送分解为多个数据包。
C251 COMPILER V5.60.0,  bno08x                                                             11/07/24  00:41:03  PAGE 15  

  901          char sendPacket(unsigned char channelNumber, unsigned char dataLength)
  902          {
  903   1          unsigned char packetLength = dataLength + 4; // Add four bytes for the header
  904   1          // if(packetLength > I2C_BUFFER_LENGTH) return(0); //You are trying to send too much. Break into smal
             -ler packets.
  905   1          unsigned char i = 0;
  906   1          // Send the 4 byte packet header
  907   1          i2c_tmp[0] = (packetLength & 0xFF);             // Packet length LSB
  908   1          i2c_tmp[1] = (0);                               // Packet length MSB
  909   1          i2c_tmp[2] = (channelNumber);                   // Channel number
  910   1          i2c_tmp[3] = (sequenceNumber[channelNumber]++); // Send the sequence number, increments with each pac
             -ket sent, different counter for each channel
  911   1      
  912   1          // Send the user's data packet
  913   1          for (i = 0; i < dataLength; i++)
  914   1          {
  915   2              i2c_tmp[4 + i] = (shtpData[i]);
  916   2          }
  917   1          WriteNbyte(i2c_tmp, (u8)(dataLength + 4));
  918   1      
  919   1          return (1);
  920   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2008     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       270         15
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        81     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
